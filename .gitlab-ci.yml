image: harbor.vakaxalab.com/sysad/docker/kube-tool

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_PATHS: "builder:docker/builder/Dockerfile sendbtc:Vakapay.SendBitcoin/Dockerfile"
  CHART_FOLDER: docker/chart

stages:
  - test
  - build_builder
  - build_program
  - review
  - staging
  - production
  - cleanup

builder:
  stage: build_builder
  image: docker
  services:
  - docker:dind
  script:
    - setup_docker
    - build builder
  only:
    - master
    - release

sendbtc:
  stage: build_program
  image: docker
  services:
  - docker:dind
  script:
    - setup_docker
    - build sendbtc
  only:
    - master
    - release

review:
  stage: review
  script:
    - check_deploy_token
    - init_chart
    - ensure_namespace
    - create_secret
    - deploy
  environment:
    name: review/$CI_COMMIT_REF_NAME
    on_stop: stop_review
    url: https://$CI_ENVIRONMENT_SLUG.$BASE_DOMAIN
  only:
    refs:
      - tags
    kubernetes: active

stop_review:
  stage: cleanup
  variables:
    GIT_STRATEGY: none
  script:
    - delete
  environment:
    name: review/$CI_COMMIT_REF_NAME
    action: stop
  when: manual
  allow_failure: true
  only:
    refs:
      - tags
    kubernetes: active

staging:
  stage: staging
  script:
    - check_deploy_token
    - init_chart
    - ensure_namespace
    - create_secret
    - deploy
  environment:
    name: staging
    url: https://$BASE_DOMAIN
  only:
    refs:
      - master
    kubernetes: active

.production: &production_template
  stage: production
  script:
    - check_deploy_token
    - init_chart
    - ensure_namespace
    - create_secret
    - deploy
  environment:
    name: production

production:
  <<: *production_template
  only:
    refs:
      - release
    kubernetes: active


# ---------------------------------------------------------------------------

.auto_devops: &auto_devops |
  [[ "$TRACE" ]] && set -x
  export RELEASE_NAME="$CI_PROJECT_PATH_SLUG-$(echo ${CI_ENVIRONMENT_NAME/\//-} | tr -s  '[:upper:]'  '[:lower:]' )"
  export CI_APPLICATION_REPOSITORY=$CI_REGISTRY_IMAGE
  export CI_APPLICATION_TAG=${CI_COMMIT_SHA:0:8}

  function get_replicas() {
    track="${1:-stable}"

    env_track=$( echo $track | tr -s  '[:lower:]'  '[:upper:]' )
    env_slug=$( echo ${CI_ENVIRONMENT_SLUG//-/_} | tr -s  '[:lower:]'  '[:upper:]' )

    if [[ "$track" == "stable" ]]; then
      # for stable track get number of replicas from `PRODUCTION_REPLICAS`
      eval new_replicas=\$${env_slug}_REPLICAS
      if [[ -z "$new_replicas" ]]; then
        new_replicas=$REPLICAS
      fi
    else
      # for all tracks get number of replicas from `CANARY_PRODUCTION_REPLICAS`
      eval new_replicas=\$${env_track}_${env_slug}_REPLICAS
      if [[ -z "$new_replicas" ]]; then
        eval new_replicas=\${env_track}_REPLICAS
      fi
    fi

    replicas="${new_replicas:-1}"

    # always return at least one replicas
    if [[ $replicas -gt 0 ]]; then
      echo "$replicas"
    else
      echo 1
    fi
  }

  function deploy() {
    track="${1-stable}"
    name=$RELEASE_NAME

    replicas="1"
    service_enabled="true"

    # if track is different than stable,
    # re-use all attached resources
    if [[ "$track" != "stable" ]]; then
      name="$RELEASE_NAME-$track"
      service_enabled="false"
    fi

    replicas=$(get_replicas "$track")

    if [[ "$CI_PROJECT_VISIBILITY" != "public" ]]; then
      secret_name="$CI_PROJECT_PATH_SLUG-registry"
    else
      secret_name=''
    fi

    (
      echo "cat <<EOF > values.yml";
      cat $CHART_FOLDER/values.yaml;
      echo;
      echo "EOF";
    ) > temp.sh
    . temp.sh

    [[ "$TRACE" ]] && cat values.yml

    helm upgrade --install \
      --wait \
      --namespace="$KUBE_NAMESPACE" \
      --version="$CI_PIPELINE_ID-$CI_JOB_ID" \
      -f values.yml \
      "$name" \
      $CHART_FOLDER/
  }

  function setup_docker() {
    if ! docker info &>/dev/null; then
      if [ -z "$DOCKER_HOST" -a "$KUBERNETES_PORT" ]; then
        export DOCKER_HOST='tcp://localhost:2375'
      fi
    fi

    if [[ -n "$CI_REGISTRY_USER" ]]; then
      echo "Logging to GitLab Container Registry with CI credentials..."
      docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
      echo ""
    fi
  }

  function init_chart() {
    helm init --client-only
    helm dependency update $CHART_FOLDER/
    helm dependency build $CHART_FOLDER/
  }

  function ensure_namespace() {
    kubectl describe namespace "$KUBE_NAMESPACE" || kubectl create namespace "$KUBE_NAMESPACE"
  }

  function check_deploy_token() {
    if [ -z $CI_DEPLOY_USER ]; then
      echo "In order to deploy or use Review Apps, must have Deploy Token of your project"
      false
    else
      true
    fi
  }

  function build() {
    echo "Building Dockerfile-based application..."
    image_tag=$CI_APPLICATION_TAG
    case $1 in
      builder)
        image_path="docker/builder/Dockerfile"
        image_tag="latest"
        ;;
      sendbtc)
        image_path="Vakapay.SendBitcoin/Dockerfile"
        ;;
    esac


    if [[ -f $image_path ]]; then
      docker build -t "$CI_APPLICATION_REPOSITORY/$1:$image_tag" -f $image_path . --network host
    else
      echo "Must have Dockerfile in your project's code"
    fi

    echo "Pushing to GitLab Container Registry..."
    docker push "$CI_APPLICATION_REPOSITORY/$1:$image_tag"
    echo ""
  }

  function create_secret() {
    echo "Create secret..."
    if [[ "$CI_PROJECT_VISIBILITY" == "public" ]]; then
      return
    fi

    kubectl create secret -n "$KUBE_NAMESPACE" \
      docker-registry "$CI_PROJECT_PATH_SLUG-registry" \
      --docker-server="$CI_REGISTRY" \
      --docker-username="$CI_DEPLOY_USER" \
      --docker-password="$CI_DEPLOY_PASSWORD" \
      --docker-email="$GITLAB_USER_EMAIL" \
      -o yaml --dry-run | kubectl replace -n "$KUBE_NAMESPACE" --force -f -
  }

  function delete() {
    track="${1-stable}"
    name=$RELEASE_NAME

    if [[ "$track" != "stable" ]]; then
      name="$name-$track"
    fi

    if [[ -n "$(helm ls -q "^$name$")" ]]; then
      helm delete "$name"
    fi
  }

before_script:
  - *auto_devops
